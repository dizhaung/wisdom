{
    "docs": [
        {
            "location": "/",
            "text": "Wisdom Stream Processor\n\n\nWisdom is an adaptive, distributed and self-boosting stream processor written in Java 9 using modern architecture from the scratch. Though I designed and developed Wisdom for my research project, my OCD in designing scalable and extensible architecture made Wisdom an industry ready product with all basic requirements. I admit that Wisdom may lack some features that you are looking for. For example, right now Wisdom does not support database integration. It is only because my research did not require those features and I do not have enough time to add those extra nice-to-have features. After publishing all my research works, Wisdom will be made open source.\n\n\nIf you like to invest in Wisdom, please contact me via \nslgobinath@gmail.com\n.\n\n\nIf you are looking for an easy to use stream processor with fresh design and less complexity for your research, you are at the right place. Just drop me an email: \nslgobinath@gmail.com\n.",
            "title": "Home"
        },
        {
            "location": "/#wisdom-stream-processor",
            "text": "Wisdom is an adaptive, distributed and self-boosting stream processor written in Java 9 using modern architecture from the scratch. Though I designed and developed Wisdom for my research project, my OCD in designing scalable and extensible architecture made Wisdom an industry ready product with all basic requirements. I admit that Wisdom may lack some features that you are looking for. For example, right now Wisdom does not support database integration. It is only because my research did not require those features and I do not have enough time to add those extra nice-to-have features. After publishing all my research works, Wisdom will be made open source.  If you like to invest in Wisdom, please contact me via  slgobinath@gmail.com .  If you are looking for an easy to use stream processor with fresh design and less complexity for your research, you are at the right place. Just drop me an email:  slgobinath@gmail.com .",
            "title": "Wisdom Stream Processor"
        },
        {
            "location": "/why-wisdom/",
            "text": "There are plenty of stream processors out there but Wisdom does not just increase the count. It is adaptive, distributable and self-boosting without compromising the performance.\n\n\nAdaptive and Tunable\n\n\nOne of the key selling point of Wisdom is its adaptiveness. Wisdom queries can be defined using variables and Wisdom will tune them based on a loss function you define. Optimization algorithms and other techniques are included in an upcoming research paper.\n\n\nPerformace\n\n\nA common limitation I have observed in dynamic stream processors \nis their performance bottleneck. I designed the underlying architecure of Wisdom in such a way that it is comparable with existing commercial stream processors. I developed a simple filter query to compare Wisdom with \nApache Flink\n, \nWSO2 Siddhi\n and \nEsper CEP\n. The throughput and latency of Wisdom is closed to WSO2 Siddhi and better than Esper. Exact perfomance results are included in the research paper.\n\n\nSelf-Boosting\n\n\nIn our research, we have shown that Wisdom consumes significantly fewer system resources than other distributed stream processors. The complete deployment setup and how it works are described in our research paper.\n\n\nWisdom Query\n\n\nWisdom Query is an SQL like query inspired by \nSiddhi Query\n. An expressive query language hides the complexity of stream processing and make it super easy to use stream processors. In addition, it lets you deploy CEP applications via REST API calls instead of transfering a deployable \njar\n file or any other binary file.",
            "title": "Why Wisdom?"
        },
        {
            "location": "/why-wisdom/#adaptive-and-tunable",
            "text": "One of the key selling point of Wisdom is its adaptiveness. Wisdom queries can be defined using variables and Wisdom will tune them based on a loss function you define. Optimization algorithms and other techniques are included in an upcoming research paper.",
            "title": "Adaptive and Tunable"
        },
        {
            "location": "/why-wisdom/#performace",
            "text": "A common limitation I have observed in dynamic stream processors \nis their performance bottleneck. I designed the underlying architecure of Wisdom in such a way that it is comparable with existing commercial stream processors. I developed a simple filter query to compare Wisdom with  Apache Flink ,  WSO2 Siddhi  and  Esper CEP . The throughput and latency of Wisdom is closed to WSO2 Siddhi and better than Esper. Exact perfomance results are included in the research paper.",
            "title": "Performace"
        },
        {
            "location": "/why-wisdom/#self-boosting",
            "text": "In our research, we have shown that Wisdom consumes significantly fewer system resources than other distributed stream processors. The complete deployment setup and how it works are described in our research paper.",
            "title": "Self-Boosting"
        },
        {
            "location": "/why-wisdom/#wisdom-query",
            "text": "Wisdom Query is an SQL like query inspired by  Siddhi Query . An expressive query language hides the complexity of stream processing and make it super easy to use stream processors. In addition, it lets you deploy CEP applications via REST API calls instead of transfering a deployable  jar  file or any other binary file.",
            "title": "Wisdom Query"
        },
        {
            "location": "/getting-started/",
            "text": "Wisdom offers a complete Java API and Wisdom query to develop Complex Event Processing (CEP) applications. Wisdom can be used as a Java library or standalone service. Java library is recommended for testing purposes, small scale applications and Android applications. If you are developing a resource consuming CEP application, it is recommended to use Wisdom Service. Wisdom Service is the only way to use HTTP Source and Sinks. This section explains how to create a simple CEP application using Wisdom Java API and Wisdom Query.\n\n\nRequirements\n\n\nMake sure that you have set up the following softwares in your system before building Wisdom.\n\n\n\n\nJava 9 (or latest)\n\n\nApache Maven\n\n\nApache Kafka (for self-boosting deployment)\n\n\n\n\nInstallation\n\n\nPlease contact me (\nslgobinath@gmail.com\n) to get access to Wisdom source code. Once you have downloaded the Wisdom source code, follow these steps to build and install Wisdom library.\n\n\nOpen your terminal and change directory\n\n\ncd wisdom\n\n\n\n\nCompile and install Wisdom using Apache Maven\n\n\nmvn clean install\n\n\n\n\nWisdom Java API\n\n\nCreate a new Maven Project in your favorite IDE. We use \nIntelliJ IDEA\n throughout this document.\n\n\nOpen the \npom.xml\n file add \nwisdom-core\n and optionally \nlogback\n dependencies as shown below:\n\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.javahelps</groupId>\n    <artifactId>wisdom-java-api</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <configuration>\n                    <source>1.9</source>\n                    <target>1.9</target>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n\n    <properties>\n        <wisdom.version>0.0.1</wisdom.version>\n        <slf4j.version>1.7.25</slf4j.version>\n        <logback.version>1.2.3</logback.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>com.javahelps.wisdom</groupId>\n            <artifactId>wisdom-core</artifactId>\n            <version>${wisdom.version}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-core</artifactId>\n            <version>${logback.version}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>${logback.version}</version>\n        </dependency>\n    </dependencies>\n\n</project>\n\n\n\n\nCreate a new Java class \ncom.javahelps.helloworld.javaapi.HelloWorld\n with the following code.\n\n\npackage com.javahelps.helloworld.javaapi;\n\nimport com.javahelps.wisdom.core.WisdomApp;\nimport com.javahelps.wisdom.core.operator.Operator;\nimport com.javahelps.wisdom.core.stream.InputHandler;\nimport com.javahelps.wisdom.core.util.EventGenerator;\nimport com.javahelps.wisdom.core.util.EventPrinter;\n\npublic class HelloWorld {\n\n    public static void main(String[] args) {\n\n        // Create a Wisdom application\n        WisdomApp app = new WisdomApp(\"WisdomApp\", \"1.0.0\");\n\n        // Define streams\n        app.defineStream(\"StockStream\");\n        app.defineStream(\"OutputStream\");\n\n        // Create a query\n        app.defineQuery(\"FilterQuery\")\n                .from(\"StockStream\")\n                .filter(Operator.EQUALS(\"symbol\", \"AMAZON\"))\n                .select(\"symbol\", \"price\")\n                .insertInto(\"OutputStream\");\n\n        // Add output stream callback\n        app.addCallback(\"OutputStream\", EventPrinter::print);\n\n        // Get an input handler\n        InputHandler inputHandler = app.getInputHandler(\"StockStream\");\n\n        // Start the application\n        app.start();\n\n        // Send three inputs\n        inputHandler.send(EventGenerator.generate(\"symbol\", \"GOOGLE\", \"price\", 10.5, \"volume\", 10L));\n        inputHandler.send(EventGenerator.generate(\"symbol\", \"AMAZON\", \"price\", 20.5, \"volume\", 20L));\n        inputHandler.send(EventGenerator.generate(\"symbol\", \"FACEBOOK\", \"price\", 30.5, \"volume\", 30L));\n\n        // Shutdown the application\n        app.shutdown();\n    }\n}\n\n\n\n\nAbove code creates Wisdom application with two streams: \nStockStream\n and \nOutputStream\n, and a query named \nFilterQuery\n. The \nFilterQuery\n filters stock events of \nAMAZON\n, select \nsymbol\n and \nprice\n, and insert them into the \nOutputStream\n. \nInputHandler\n is used to feed events to a stream and callback is used to receive events from a stream.\n\n\nRunning this code should print an output similar to this:\n\n\n[Event{timestamp=1524709449322, stream=OutputStream, data={symbol=AMAZON, price=20.5}, expired=false}]\n\n\n\n\nAs you can see, above Wisdom app filters events having symbol equal to AMAZON and prints them to the console.\n\n\nWisdom Query\n\n\nAbove Wisdom application can be defined using the folloing Wisdom query:\n\n\n@app(name='WisdomApp', version='1.0.0')\ndef stream StockStream;\ndef stream OutputStream;\n\n@query(name='FilterQuery')\nfrom StockStream\nfilter symbol == 'AMAZON'\nselect symbol, price\ninsert into OutputStream;\n\n\n\n\nTo use this query in a Java application, create a new Maven project in your favorite IDE.\n\n\nOpen the \npom.xml\n file and add \nwisdom-core\n, \nwisdom-query\n and optionally \nlogback\n dependencies as shown below:\n\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.javahelps</groupId>\n    <artifactId>wisdom-java-api</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <configuration>\n                    <source>1.9</source>\n                    <target>1.9</target>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n\n    <properties>\n        <wisdom.version>0.0.1</wisdom.version>\n        <slf4j.version>1.7.25</slf4j.version>\n        <logback.version>1.2.3</logback.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>com.javahelps.wisdom</groupId>\n            <artifactId>wisdom-core</artifactId>\n            <version>${wisdom.version}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>com.javahelps.wisdom</groupId>\n            <artifactId>wisdom-query</artifactId>\n            <version>${wisdom.version}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-core</artifactId>\n            <version>${logback.version}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>${logback.version}</version>\n        </dependency>\n    </dependencies>\n\n</project>\n\n\n\n\nCreate a new Java class \ncom.javahelps.helloworld.wisdomql.HelloWorld\n with the following code.\n\n\npackage com.javahelps.helloworld.wisdomql;\n\nimport com.javahelps.wisdom.core.WisdomApp;\nimport com.javahelps.wisdom.core.stream.InputHandler;\nimport com.javahelps.wisdom.core.util.EventGenerator;\nimport com.javahelps.wisdom.core.util.EventPrinter;\nimport com.javahelps.wisdom.query.WisdomCompiler;\n\npublic class HelloWorld {\n\n    public static void main(String[] args) {\n\n        String query = \"@app(name='WisdomApp', version='1.0.0') \" +\n                \"def stream StockStream; \" +\n                \"def stream OutputStream; \" +\n                \" \" +\n                \"@query(name='FilterQuery') \" +\n                \"from StockStream \" +\n                \"filter symbol == 'AMAZON' \" +\n                \"select symbol, price \" +\n                \"insert into OutputStream;\";\n\n        // Create a Wisdom application\n        WisdomApp app = WisdomCompiler.parse(query);\n\n        // Add output stream callback\n        app.addCallback(\"OutputStream\", EventPrinter::print);\n\n        // Get an input handler\n        InputHandler inputHandler = app.getInputHandler(\"StockStream\");\n\n        // Start the application\n        app.start();\n\n        // Send three inputs\n        inputHandler.send(EventGenerator.generate(\"symbol\", \"GOOGLE\", \"price\", 10.5, \"volume\", 10L));\n        inputHandler.send(EventGenerator.generate(\"symbol\", \"AMAZON\", \"price\", 20.5, \"volume\", 20L));\n        inputHandler.send(EventGenerator.generate(\"symbol\", \"FACEBOOK\", \"price\", 30.5, \"volume\", 30L));\n\n        // Shutdown the application\n        app.shutdown();\n    }\n}\n\n\n\n\nAbove code replaces the Java API used in previous example by the Wisdom query to construct a Wisdom app. Once the Wisdom app is created, creating InputHandler and sending events are same as the previous example.",
            "title": "Getting Started"
        },
        {
            "location": "/getting-started/#requirements",
            "text": "Make sure that you have set up the following softwares in your system before building Wisdom.   Java 9 (or latest)  Apache Maven  Apache Kafka (for self-boosting deployment)",
            "title": "Requirements"
        },
        {
            "location": "/getting-started/#installation",
            "text": "Please contact me ( slgobinath@gmail.com ) to get access to Wisdom source code. Once you have downloaded the Wisdom source code, follow these steps to build and install Wisdom library.  Open your terminal and change directory  cd wisdom  Compile and install Wisdom using Apache Maven  mvn clean install",
            "title": "Installation"
        },
        {
            "location": "/getting-started/#wisdom-java-api",
            "text": "Create a new Maven Project in your favorite IDE. We use  IntelliJ IDEA  throughout this document.  Open the  pom.xml  file add  wisdom-core  and optionally  logback  dependencies as shown below:  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.javahelps</groupId>\n    <artifactId>wisdom-java-api</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <configuration>\n                    <source>1.9</source>\n                    <target>1.9</target>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n\n    <properties>\n        <wisdom.version>0.0.1</wisdom.version>\n        <slf4j.version>1.7.25</slf4j.version>\n        <logback.version>1.2.3</logback.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>com.javahelps.wisdom</groupId>\n            <artifactId>wisdom-core</artifactId>\n            <version>${wisdom.version}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-core</artifactId>\n            <version>${logback.version}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>${logback.version}</version>\n        </dependency>\n    </dependencies>\n\n</project>  Create a new Java class  com.javahelps.helloworld.javaapi.HelloWorld  with the following code.  package com.javahelps.helloworld.javaapi;\n\nimport com.javahelps.wisdom.core.WisdomApp;\nimport com.javahelps.wisdom.core.operator.Operator;\nimport com.javahelps.wisdom.core.stream.InputHandler;\nimport com.javahelps.wisdom.core.util.EventGenerator;\nimport com.javahelps.wisdom.core.util.EventPrinter;\n\npublic class HelloWorld {\n\n    public static void main(String[] args) {\n\n        // Create a Wisdom application\n        WisdomApp app = new WisdomApp(\"WisdomApp\", \"1.0.0\");\n\n        // Define streams\n        app.defineStream(\"StockStream\");\n        app.defineStream(\"OutputStream\");\n\n        // Create a query\n        app.defineQuery(\"FilterQuery\")\n                .from(\"StockStream\")\n                .filter(Operator.EQUALS(\"symbol\", \"AMAZON\"))\n                .select(\"symbol\", \"price\")\n                .insertInto(\"OutputStream\");\n\n        // Add output stream callback\n        app.addCallback(\"OutputStream\", EventPrinter::print);\n\n        // Get an input handler\n        InputHandler inputHandler = app.getInputHandler(\"StockStream\");\n\n        // Start the application\n        app.start();\n\n        // Send three inputs\n        inputHandler.send(EventGenerator.generate(\"symbol\", \"GOOGLE\", \"price\", 10.5, \"volume\", 10L));\n        inputHandler.send(EventGenerator.generate(\"symbol\", \"AMAZON\", \"price\", 20.5, \"volume\", 20L));\n        inputHandler.send(EventGenerator.generate(\"symbol\", \"FACEBOOK\", \"price\", 30.5, \"volume\", 30L));\n\n        // Shutdown the application\n        app.shutdown();\n    }\n}  Above code creates Wisdom application with two streams:  StockStream  and  OutputStream , and a query named  FilterQuery . The  FilterQuery  filters stock events of  AMAZON , select  symbol  and  price , and insert them into the  OutputStream .  InputHandler  is used to feed events to a stream and callback is used to receive events from a stream.  Running this code should print an output similar to this:  [Event{timestamp=1524709449322, stream=OutputStream, data={symbol=AMAZON, price=20.5}, expired=false}]  As you can see, above Wisdom app filters events having symbol equal to AMAZON and prints them to the console.",
            "title": "Wisdom Java API"
        },
        {
            "location": "/getting-started/#wisdom-query",
            "text": "Above Wisdom application can be defined using the folloing Wisdom query:  @app(name='WisdomApp', version='1.0.0')\ndef stream StockStream;\ndef stream OutputStream;\n\n@query(name='FilterQuery')\nfrom StockStream\nfilter symbol == 'AMAZON'\nselect symbol, price\ninsert into OutputStream;  To use this query in a Java application, create a new Maven project in your favorite IDE.  Open the  pom.xml  file and add  wisdom-core ,  wisdom-query  and optionally  logback  dependencies as shown below:  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.javahelps</groupId>\n    <artifactId>wisdom-java-api</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <configuration>\n                    <source>1.9</source>\n                    <target>1.9</target>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n\n    <properties>\n        <wisdom.version>0.0.1</wisdom.version>\n        <slf4j.version>1.7.25</slf4j.version>\n        <logback.version>1.2.3</logback.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>com.javahelps.wisdom</groupId>\n            <artifactId>wisdom-core</artifactId>\n            <version>${wisdom.version}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>com.javahelps.wisdom</groupId>\n            <artifactId>wisdom-query</artifactId>\n            <version>${wisdom.version}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-core</artifactId>\n            <version>${logback.version}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>${logback.version}</version>\n        </dependency>\n    </dependencies>\n\n</project>  Create a new Java class  com.javahelps.helloworld.wisdomql.HelloWorld  with the following code.  package com.javahelps.helloworld.wisdomql;\n\nimport com.javahelps.wisdom.core.WisdomApp;\nimport com.javahelps.wisdom.core.stream.InputHandler;\nimport com.javahelps.wisdom.core.util.EventGenerator;\nimport com.javahelps.wisdom.core.util.EventPrinter;\nimport com.javahelps.wisdom.query.WisdomCompiler;\n\npublic class HelloWorld {\n\n    public static void main(String[] args) {\n\n        String query = \"@app(name='WisdomApp', version='1.0.0') \" +\n                \"def stream StockStream; \" +\n                \"def stream OutputStream; \" +\n                \" \" +\n                \"@query(name='FilterQuery') \" +\n                \"from StockStream \" +\n                \"filter symbol == 'AMAZON' \" +\n                \"select symbol, price \" +\n                \"insert into OutputStream;\";\n\n        // Create a Wisdom application\n        WisdomApp app = WisdomCompiler.parse(query);\n\n        // Add output stream callback\n        app.addCallback(\"OutputStream\", EventPrinter::print);\n\n        // Get an input handler\n        InputHandler inputHandler = app.getInputHandler(\"StockStream\");\n\n        // Start the application\n        app.start();\n\n        // Send three inputs\n        inputHandler.send(EventGenerator.generate(\"symbol\", \"GOOGLE\", \"price\", 10.5, \"volume\", 10L));\n        inputHandler.send(EventGenerator.generate(\"symbol\", \"AMAZON\", \"price\", 20.5, \"volume\", 20L));\n        inputHandler.send(EventGenerator.generate(\"symbol\", \"FACEBOOK\", \"price\", 30.5, \"volume\", 30L));\n\n        // Shutdown the application\n        app.shutdown();\n    }\n}  Above code replaces the Java API used in previous example by the Wisdom query to construct a Wisdom app. Once the Wisdom app is created, creating InputHandler and sending events are same as the previous example.",
            "title": "Wisdom Query"
        },
        {
            "location": "/deploy-wisdom/",
            "text": "Wisdom offers three different deployment options: (1) in-app usage as a Java library, (2) stand-alone deployment as a microservice, (3) Wisdom Orchestra deployment.\n\n\nWisdom Library\n\n\nThis is the recommended method to use Wisdom if you are developing a new Wisdom rule or if you want to playwith Wisdom. It is also recommended for applications require in-app complex event processing. Please check the \nGetting Started\n guidelines to use Wisdom as a library.\n\n\nWisdom Service\n\n\nWisdom Service is recommended if you are deploying a stand-alone CEP rule which requires HTTP endpoints and/or more system resources to be allocated. You can either use the Wisdom server to run your query or develop your own microservice to run your Wisdom app.\n\n\nDeploy Wisdom Query Using Wisdom Server\n\n\nStep 1:\n Email the author(\nslgobinath@gmail.com\n) and get the Wisdom Server pack.\n\n\nStep 2:\n Extract the zip file and navigate into the extracted directory.\n\n\nunzip product-wisdom-0.0.1.zip\ncd product-wisdom-0.0.1\n\n\n\n\nStep 3:\n Save the following Wisdom query into the \nartifacts\n directory with a name: \nstock_filter.wisdomql\n.\n\n\n@app(name='stock_filter', version='1.0.0')\n\n@source(type='http', mapping='json')\ndef stream StockStream;\n\n@sink(type='console')\ndef stream OutputStream;\n\n@query(name='FilterQuery')\nfrom StockStream\nfilter symbol == 'AMAZON'\nselect symbol, price\ninsert into OutputStream;\n\n\n\n\nStep 4:\n Start the Wisdom Service on port \n8080\n using the following command:\n\n\nsh wisdom-service.sh --port 8080 artifacts/stock_filter.wisdomql\n\n\n\n\nStep 5:\n Using \nPostman\n or similar tools, send an event using HTTP POST request. For simplicity, we use \ncurl\n to send the request.\n\n\ncurl -d '{\"symbol\": \"AMAZON\", \"price\": 120.0, \"volume\": 10}' -H \"Content-Type: application/json\" -X POST http://localhost:8080/WisdomApp/StockStream\n\n\n\n\nAfter sending this request, you should see the the following output in the terminal running Wisdom service:\n\n\nEvent{timestamp=1524757628355, stream=OutputStream, data={symbol=AMAZON, price=120.0}, expired=false}\n\n\n\n\nWisdom Orchestra\n\n\nWisdom Orchestra deployment is a fancy name I use to refer managing Wisdom instances using Wisdom Manager. Wisdom Manager is a specially designed tool to deploy and manage Wisdom services. It can be used to deploy stand-alone Wisdom services or to deploy self-boosting Wisdom environment.\n\n\nWisdom Manager often requires \nApache Kafka\n to coordinate and communicate with Wisdom instances. Therefore, please setup and start Apache Kakfa before running Wisdom Manager.\n\n\nStep 1:\n Download and extract the latest \nApache Kafka\n anywhere in your system.\n\n\nStep 2:\n Start Apache Kafka using the following two commands from \nKAFKA_HOME\n.\n\n\n# Start Zookeeper server\nsh bin/zookeeper-server-start.sh config/zookeeper.properties\n\n# Start Kafka server\nsh bin/kafka-server-start.sh config/server.properties\n\n\n\n\nStep 3:\n Open another terminal in \nWISDOM_HOME\n and start the Wisdom Manager.\n\n\nsh wisdom-manager.sh\n\n\n\n\nStep 4:\n Send an HTTP POST request with a Wisdom query along with a port to start that query.\n\n\ncurl -d \"{\\\"query\\\": \\\"@app(name='stock_filter', version='1.0.0') \\\n@source(type='http', mapping='json') \\\ndef stream StockStream; \\\n@sink(type='file.text', path='/tmp/OutputStream.txt') \\\ndef stream OutputStream; \\\n@query(name='FilterQuery') \\\nfrom StockStream \\\nfilter symbol == 'AMAZON' \\\nselect symbol, price \\\ninsert into OutputStream;\\\", \\\"port\\\": 8085}\" -H \"Content-Type: application/json\" -X POST http://localhost:8080/WisdomManager/app\n\n\n\n\nNote that the OutputStream sink is a text file: \n/tmp/OutputStream.txt\n.\n\n\nStep 5:\n Start \nstock_filter\n by sending another POST request.\n\n\ncurl -X POST http://localhost:8080/WisdomManager/start/stock_filter\n\n\n\n\nStep 06:\n Test \nstock_filter\n by sending a stock event.\n\n\ncurl -d '{\"symbol\": \"AMAZON\", \"price\": 120.0, \"volume\": 10}' -H \"Content-Type: application/json\" -X POST http://localhost:8085/WisdomApp/StockStream\n\n\n\n\nAfter sending above event, you should have a file \n/tmp/OutputStream.txt\n with the following content:\n\n\nEvent{timestamp=1524761284277, stream=OutputStream, data={symbol=AMAZON, price=120.0}, expired=false}\n\n\n\n\nStep 07:\n Stop the \nstock_filter\n app\n\n\ncurl -X POST http://localhost:8080/WisdomManager/stop/stock_filter\n\n\n\n\nStep 08:\n Delete the \nstock_filter\n app\n\n\ncurl -X DELETE http://localhost:8080/WisdomManager/app/stock_filter\n\n\n\n\nStep 09:\n Stop the Wisdom Manager\n\n\ncurl -X POST http://localhost:8080/WisdomManager/stop",
            "title": "Deploy Wisdom"
        },
        {
            "location": "/deploy-wisdom/#wisdom-library",
            "text": "This is the recommended method to use Wisdom if you are developing a new Wisdom rule or if you want to playwith Wisdom. It is also recommended for applications require in-app complex event processing. Please check the  Getting Started  guidelines to use Wisdom as a library.",
            "title": "Wisdom Library"
        },
        {
            "location": "/deploy-wisdom/#wisdom-service",
            "text": "Wisdom Service is recommended if you are deploying a stand-alone CEP rule which requires HTTP endpoints and/or more system resources to be allocated. You can either use the Wisdom server to run your query or develop your own microservice to run your Wisdom app.  Deploy Wisdom Query Using Wisdom Server  Step 1:  Email the author( slgobinath@gmail.com ) and get the Wisdom Server pack.  Step 2:  Extract the zip file and navigate into the extracted directory.  unzip product-wisdom-0.0.1.zip\ncd product-wisdom-0.0.1  Step 3:  Save the following Wisdom query into the  artifacts  directory with a name:  stock_filter.wisdomql .  @app(name='stock_filter', version='1.0.0')\n\n@source(type='http', mapping='json')\ndef stream StockStream;\n\n@sink(type='console')\ndef stream OutputStream;\n\n@query(name='FilterQuery')\nfrom StockStream\nfilter symbol == 'AMAZON'\nselect symbol, price\ninsert into OutputStream;  Step 4:  Start the Wisdom Service on port  8080  using the following command:  sh wisdom-service.sh --port 8080 artifacts/stock_filter.wisdomql  Step 5:  Using  Postman  or similar tools, send an event using HTTP POST request. For simplicity, we use  curl  to send the request.  curl -d '{\"symbol\": \"AMAZON\", \"price\": 120.0, \"volume\": 10}' -H \"Content-Type: application/json\" -X POST http://localhost:8080/WisdomApp/StockStream  After sending this request, you should see the the following output in the terminal running Wisdom service:  Event{timestamp=1524757628355, stream=OutputStream, data={symbol=AMAZON, price=120.0}, expired=false}",
            "title": "Wisdom Service"
        },
        {
            "location": "/deploy-wisdom/#wisdom-orchestra",
            "text": "Wisdom Orchestra deployment is a fancy name I use to refer managing Wisdom instances using Wisdom Manager. Wisdom Manager is a specially designed tool to deploy and manage Wisdom services. It can be used to deploy stand-alone Wisdom services or to deploy self-boosting Wisdom environment.  Wisdom Manager often requires  Apache Kafka  to coordinate and communicate with Wisdom instances. Therefore, please setup and start Apache Kakfa before running Wisdom Manager.  Step 1:  Download and extract the latest  Apache Kafka  anywhere in your system.  Step 2:  Start Apache Kafka using the following two commands from  KAFKA_HOME .  # Start Zookeeper server\nsh bin/zookeeper-server-start.sh config/zookeeper.properties\n\n# Start Kafka server\nsh bin/kafka-server-start.sh config/server.properties  Step 3:  Open another terminal in  WISDOM_HOME  and start the Wisdom Manager.  sh wisdom-manager.sh  Step 4:  Send an HTTP POST request with a Wisdom query along with a port to start that query.  curl -d \"{\\\"query\\\": \\\"@app(name='stock_filter', version='1.0.0') \\\n@source(type='http', mapping='json') \\\ndef stream StockStream; \\\n@sink(type='file.text', path='/tmp/OutputStream.txt') \\\ndef stream OutputStream; \\\n@query(name='FilterQuery') \\\nfrom StockStream \\\nfilter symbol == 'AMAZON' \\\nselect symbol, price \\\ninsert into OutputStream;\\\", \\\"port\\\": 8085}\" -H \"Content-Type: application/json\" -X POST http://localhost:8080/WisdomManager/app  Note that the OutputStream sink is a text file:  /tmp/OutputStream.txt .  Step 5:  Start  stock_filter  by sending another POST request.  curl -X POST http://localhost:8080/WisdomManager/start/stock_filter  Step 06:  Test  stock_filter  by sending a stock event.  curl -d '{\"symbol\": \"AMAZON\", \"price\": 120.0, \"volume\": 10}' -H \"Content-Type: application/json\" -X POST http://localhost:8085/WisdomApp/StockStream  After sending above event, you should have a file  /tmp/OutputStream.txt  with the following content:  Event{timestamp=1524761284277, stream=OutputStream, data={symbol=AMAZON, price=120.0}, expired=false}  Step 07:  Stop the  stock_filter  app  curl -X POST http://localhost:8080/WisdomManager/stop/stock_filter  Step 08:  Delete the  stock_filter  app  curl -X DELETE http://localhost:8080/WisdomManager/app/stock_filter  Step 09:  Stop the Wisdom Manager  curl -X POST http://localhost:8080/WisdomManager/stop",
            "title": "Wisdom Orchestra"
        },
        {
            "location": "/query-guide/",
            "text": "A Wisdom application can be created either using Java API or Wisdom Query Language. Wisdom Query Language is a SQL like query inspired by \nSiddhi Query\n. A Wisdom query should follow this template:\n\n\n<app annotation>?\n( <stream definition> | <variable definition> | ... ) + \n( <query> ) +\n;\n\n\n\n\nStream\n\n\nStream is a the most basic component of stream processor. In Wisdom, you need to define a stream before using it. Wisdom streams are dynamic typed like Python so you cannot define attributes of s stream. At the runtime, whatever you pass will be accepted by the stream.\n\n\nJava API:\n\n\napp.defineStream(\"StockStream\");\n\n\n\n\nWisdom Query:\n\n\ndef stream StockStream;\n\n\n\n\nFilter\n\n\nFilter is an operator to filter events coming from a stream. In Wisdom query, a \nfilter\n can be used anywhere in between \nfrom\n and \ninsert into\n statements.\n\n\nJava API:\n\n\napp.defineQuery(\"query1\")\n    .from(\"StockStream\")\n    .filter(event -> \"UWO\".equals(event.get(\"stock\")))\n    .insertInto(\"OutputStream\");\n\n\n\n\nIn Java API, the \nfilter\n method accepts any \njava.util.function.Predicate<Event>\n as the argument. For user's convenient, Wisdom offers some built-in predicates:\n\n\n\n\nOperator.EQUALS\n\n\nOperator.GREATER_THAN\n\n\nOperator.GREATER_THAN_OR_EQUAL\n\n\nOperator.LESS_THAN\n\n\nOperator.LESS_THAN_OR_EQUAL\n\n\nOperator.STR_IN_ATTR and its variants\n\n\n\n\nAbove code can be written using built-in \nOperator.EQUALS\n predicate as shown below:\n\n\napp.defineQuery(\"query1\")\n    .from(\"StockStream\")\n    .filter(Operator.EQUALS(\"stock\", \"AMAZON\"))\n    .insertInto(\"OutputStream\");\n\n\n\n\nWisdom Query:\n\n\nfrom StockStream\nfilter symbol == 'UWO'\ninsert into OutputStream;\n\n\n\n\nWisdom Query supports the following logical operators: \n==\n, \n>\n, \n>=\n, \n<\n, \n<=\n and \nin\n\n\nWindow\n\n\nWindows are used to batch events based on some conditions. Wisdom 0.0.1 supports the following windows:\n\n\n\n\nWindow.length\n\n\nWindow.lengthBatch\n\n\nWindow.externalTimeBatch\n\n\nUniqueWindow.lengthBatch\n\n\nUniqueWindow.externalTimeBatch\n\n\n\n\nJava API:\n\n\napp.defineQuery(\"query1\")\n    .from(\"StockStream\")\n    .window(Window.lengthBatch(3))\n    .insertInto(\"OutputStream\");\n\n\n\n\nWisdom Query:\n\n\nfrom StockStream\nwindow.lengthBatch(3)\ninsert into OutputStream;\n\n\n\n\nSelect\n\n\nSelector selects attributes and events to be inserted into the following operator. If the selector is used with attribute names, it selects the attributes from events. If selector is used with index of events after windows, it selects the specified events from the list of events.\n\n\nNOTE: Positive indices select events from the begining of list and negative indices select events from the end of list. For example \n0\n selects the first event and \n-1\n selects the last event.\n\n\nJava API:\n\n\nSelect \nsymbol\n and \nprice\n from all events and insert them into OutputStream.\n\n\napp.defineQuery(\"query1\")\n    .from(\"StockStream\")\n    .select(\"symbol\", \"price\")\n    .insertInto(\"OutputStream\");\n\n\n\n\nSelect last two events from window and insert them into OutputStream.\n\n\napp.defineQuery(\"query1\")\n    .from(\"StockStream\")\n    .window.lengthBatch(5)\n    .select(Index.of(-2, -1))\n    .insertInto(\"OutputStream\");\n\n\n\n\nWisdom Query:\n\n\nSelect \nsymbol\n and \nprice\n from all events and insert them into OutputStream.\n\n\nfrom StockStream\nselect symbol, price\ninsert into OutputStream;\n\n\n\n\nSelect last two events from window and insert them into OutputStream.\n\n\nfrom StockStream\nselect -2, -1\ninsert into OutputStream;",
            "title": "Wisdom Query Guide"
        },
        {
            "location": "/query-guide/#stream",
            "text": "Stream is a the most basic component of stream processor. In Wisdom, you need to define a stream before using it. Wisdom streams are dynamic typed like Python so you cannot define attributes of s stream. At the runtime, whatever you pass will be accepted by the stream.  Java API:  app.defineStream(\"StockStream\");  Wisdom Query:  def stream StockStream;",
            "title": "Stream"
        },
        {
            "location": "/query-guide/#filter",
            "text": "Filter is an operator to filter events coming from a stream. In Wisdom query, a  filter  can be used anywhere in between  from  and  insert into  statements.  Java API:  app.defineQuery(\"query1\")\n    .from(\"StockStream\")\n    .filter(event -> \"UWO\".equals(event.get(\"stock\")))\n    .insertInto(\"OutputStream\");  In Java API, the  filter  method accepts any  java.util.function.Predicate<Event>  as the argument. For user's convenient, Wisdom offers some built-in predicates:   Operator.EQUALS  Operator.GREATER_THAN  Operator.GREATER_THAN_OR_EQUAL  Operator.LESS_THAN  Operator.LESS_THAN_OR_EQUAL  Operator.STR_IN_ATTR and its variants   Above code can be written using built-in  Operator.EQUALS  predicate as shown below:  app.defineQuery(\"query1\")\n    .from(\"StockStream\")\n    .filter(Operator.EQUALS(\"stock\", \"AMAZON\"))\n    .insertInto(\"OutputStream\");  Wisdom Query:  from StockStream\nfilter symbol == 'UWO'\ninsert into OutputStream;  Wisdom Query supports the following logical operators:  == ,  > ,  >= ,  < ,  <=  and  in",
            "title": "Filter"
        },
        {
            "location": "/query-guide/#window",
            "text": "Windows are used to batch events based on some conditions. Wisdom 0.0.1 supports the following windows:   Window.length  Window.lengthBatch  Window.externalTimeBatch  UniqueWindow.lengthBatch  UniqueWindow.externalTimeBatch   Java API:  app.defineQuery(\"query1\")\n    .from(\"StockStream\")\n    .window(Window.lengthBatch(3))\n    .insertInto(\"OutputStream\");  Wisdom Query:  from StockStream\nwindow.lengthBatch(3)\ninsert into OutputStream;",
            "title": "Window"
        },
        {
            "location": "/query-guide/#select",
            "text": "Selector selects attributes and events to be inserted into the following operator. If the selector is used with attribute names, it selects the attributes from events. If selector is used with index of events after windows, it selects the specified events from the list of events.  NOTE: Positive indices select events from the begining of list and negative indices select events from the end of list. For example  0  selects the first event and  -1  selects the last event.  Java API:  Select  symbol  and  price  from all events and insert them into OutputStream.  app.defineQuery(\"query1\")\n    .from(\"StockStream\")\n    .select(\"symbol\", \"price\")\n    .insertInto(\"OutputStream\");  Select last two events from window and insert them into OutputStream.  app.defineQuery(\"query1\")\n    .from(\"StockStream\")\n    .window.lengthBatch(5)\n    .select(Index.of(-2, -1))\n    .insertInto(\"OutputStream\");  Wisdom Query:  Select  symbol  and  price  from all events and insert them into OutputStream.  from StockStream\nselect symbol, price\ninsert into OutputStream;  Select last two events from window and insert them into OutputStream.  from StockStream\nselect -2, -1\ninsert into OutputStream;",
            "title": "Select"
        },
        {
            "location": "/intrusion-detection/",
            "text": "Intrusion Detection\n\n\nFollowing queries were developed to detect network attacks in \nCICIDS 2017\n dataset. We developed the following rules based on facts behind each attacks. Even though we obtained an average precision of 99.98%, we are not responsible for failure of detecting real time attacks.\n\n\nFTP Brute Force Attack\n\n\nIn FTP Brute Force attack, an attacker tries different combinations of username and password to login to the FTP server. Therefore, there should be significantly large amount of failed attempts within a short period of time.\n\n\n@app(name='FTPBruteForceDetector', version='1.0.0')\ndef stream PacketStream;\ndef stream AttackStream;\n\ndef variable time_threshold = time.sec(1);\ndef variable count_threshold = 7;\n\nfrom PacketStream\n    filter 'FTP' == app_protocol and '530 Login incorrect' in data\n    partition by destIp\n    window.externalTimeBatch('timestamp', $time_threshold)\n    aggregate count() as no_of_packets\n    filter no_of_packets >= $count_threshold\n    select srcIp, destIp, no_of_packets, timestamp\ninsert into AttackStream;\n\n\n\n\nHTTP Slow Header Attack\n\n\nHTTP Slow Header attack is a Denial of Service(DOS) attack in which a victim server is compromized by sending too many HTTP incomplete requests with random \nKeep-Alive\n time. For more details, read: \nHow Secure are Web Servers? An Empirical Study of Slow HTTP DoS Attacks and Detection\n.\n\n\n@app(name='SlowHeaderDetector', version='1.0.0')\ndef stream PacketStream;\ndef stream AttackStream;\n\ndef variable time_threshold = time.sec(1);\ndef variable count_threshold = 998;\n\nfrom PacketStream\n    filter 'http' == app_protocol and destPort == 80 and '\\r\\n\\r\\n' in data and 'Keep-Alive: \\\\d+' in data\n    partition by destIp\n    window.externalTimeBatch('timestamp', $time_threshold)\n    aggregate count() as no_of_packets\n    filter no_of_packets >= $count_threshold\n    select srcIp, destIp, no_of_packets, timestamp\ninsert into AttackStream;\n\n\n\n\nPort Scanning\n\n\nEven though Port Scanning is a common technique used by attackers, it is hard to fit all types of port scans into a single CEP rule. The following rule is developed to detect \nnmap -sS\n port scan. For more details, please visit \nPort Scanning Techniques\n.\n\n\n\n@app(name='PortScanDetector', version='1.0.0')\ndef stream PacketStream;\ndef stream AttackStream;\n\n@config(trainable=true, minimum=100, maximum=60000, step=-1)\ndef variable time_threshold = 761;\n\n@config(trainable=true, minimum=3, maximum=1000, step=1)\ndef variable count_threshold = 3;\n\nfrom PacketStream\n    filter syn == true and ack == false\n    partition by srcIp, destIp\n    window.unique:externalTimeBatch('destPort', 'timestamp', $time_threshold)\n    aggregate count() as no_of_packets\n    filter no_of_packets >= $count_threshold\n    select srcIp, destIp, no_of_packets, timestamp\ninsert into AttackStream;",
            "title": "Intrusion Detection"
        },
        {
            "location": "/intrusion-detection/#intrusion-detection",
            "text": "Following queries were developed to detect network attacks in  CICIDS 2017  dataset. We developed the following rules based on facts behind each attacks. Even though we obtained an average precision of 99.98%, we are not responsible for failure of detecting real time attacks.",
            "title": "Intrusion Detection"
        },
        {
            "location": "/intrusion-detection/#ftp-brute-force-attack",
            "text": "In FTP Brute Force attack, an attacker tries different combinations of username and password to login to the FTP server. Therefore, there should be significantly large amount of failed attempts within a short period of time.  @app(name='FTPBruteForceDetector', version='1.0.0')\ndef stream PacketStream;\ndef stream AttackStream;\n\ndef variable time_threshold = time.sec(1);\ndef variable count_threshold = 7;\n\nfrom PacketStream\n    filter 'FTP' == app_protocol and '530 Login incorrect' in data\n    partition by destIp\n    window.externalTimeBatch('timestamp', $time_threshold)\n    aggregate count() as no_of_packets\n    filter no_of_packets >= $count_threshold\n    select srcIp, destIp, no_of_packets, timestamp\ninsert into AttackStream;",
            "title": "FTP Brute Force Attack"
        },
        {
            "location": "/intrusion-detection/#http-slow-header-attack",
            "text": "HTTP Slow Header attack is a Denial of Service(DOS) attack in which a victim server is compromized by sending too many HTTP incomplete requests with random  Keep-Alive  time. For more details, read:  How Secure are Web Servers? An Empirical Study of Slow HTTP DoS Attacks and Detection .  @app(name='SlowHeaderDetector', version='1.0.0')\ndef stream PacketStream;\ndef stream AttackStream;\n\ndef variable time_threshold = time.sec(1);\ndef variable count_threshold = 998;\n\nfrom PacketStream\n    filter 'http' == app_protocol and destPort == 80 and '\\r\\n\\r\\n' in data and 'Keep-Alive: \\\\d+' in data\n    partition by destIp\n    window.externalTimeBatch('timestamp', $time_threshold)\n    aggregate count() as no_of_packets\n    filter no_of_packets >= $count_threshold\n    select srcIp, destIp, no_of_packets, timestamp\ninsert into AttackStream;",
            "title": "HTTP Slow Header Attack"
        },
        {
            "location": "/intrusion-detection/#port-scanning",
            "text": "Even though Port Scanning is a common technique used by attackers, it is hard to fit all types of port scans into a single CEP rule. The following rule is developed to detect  nmap -sS  port scan. For more details, please visit  Port Scanning Techniques .  \n@app(name='PortScanDetector', version='1.0.0')\ndef stream PacketStream;\ndef stream AttackStream;\n\n@config(trainable=true, minimum=100, maximum=60000, step=-1)\ndef variable time_threshold = 761;\n\n@config(trainable=true, minimum=3, maximum=1000, step=1)\ndef variable count_threshold = 3;\n\nfrom PacketStream\n    filter syn == true and ack == false\n    partition by srcIp, destIp\n    window.unique:externalTimeBatch('destPort', 'timestamp', $time_threshold)\n    aggregate count() as no_of_packets\n    filter no_of_packets >= $count_threshold\n    select srcIp, destIp, no_of_packets, timestamp\ninsert into AttackStream;",
            "title": "Port Scanning"
        }
    ]
}